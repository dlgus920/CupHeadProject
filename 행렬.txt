행렬공식들을 통해서
아래의 숫자들이 변형되는 것을 의미한다.

0.0f 0.0f 0.0f 0.0f
0.0f 0.0f 0.0f 0.0f
0.0f 0.0f 0.0f 0.0f
0.0f 0.0f 0.0f 0.0f


// 무조건 곱하기
// 곱하기는 규칙이 있는데.

// Left
// 행 2개
// 열 2개

// Right
// 행 2개
// 열 2개

// 같으면 곱할수 있다.

Left              Right
0.0f 0.0f     *   0.0f 0.0f
0.0f 0.0f         0.0f 0.0f


// 같으면 곱할수 있다.

// 아래의 경우는 곱할수 없는데
// 이유가 뭐냐?
// 왼쪽의 행과 오른쪽의 열이 같아야만 곱할수 있다.
Left              Right
0.0f 0.0f     *   0.0f 0.0f
         

Left              Right
0.0f 0.0f     *   0.0f 
                  0.0f

Left                        Right
0.0f 0.0f 0.0f 0.0f     *   0.0f 0.0f 0.0f 0.0f
                            0.0f 0.0f 0.0f 0.0f
                            0.0f 0.0f 0.0f 0.0f
                            0.0f 0.0f 0.0f 0.0f




                            // 왼쪽의 행과 오른쪽의 열이 같아야만 곱할수 있다.

                            왼쪽의 행과
                            오른쪽 의 열이 합쳐지는 결과가 나옵니다.
A              B            1 X 1
A00 A01     *  B00          C00 
               B10           

Cij =  Ai0*b0j + Ai1*b1j

C00 =  A00*b00 + A01*b10

A                      B                   C
A00 A01 A02 A03     *  B00 B01 B02 B03  = C00 C01 C02 C03
A10 A11 A12 A13        B10 B11 B12 B13    C10 C11 C12 C13
A20 A21 A22 A23        B20 B21 B22 B23    C20 C21 C22 C23
A30 A31 A32 A33        B30 B31 B32 B33    C30 C31 C32 C33

Cij =  Ai0*b0j + Ai1*b1j + Ai2*b2j + Ai3*b3j

C00 =  A00*B00 + A01*B10 + A02*B20 + A03*B30
C01 =  A00*B01 + A01*B11 + A02*B21 + A03*B31
C02 =  A00*B02 + A01*B12 + A02*B22 + A03*B32
C03 =  A00*B03 + A01*B13 + A02*B23 + A03*B33

A              B          C
2 0 0 0     *  1 0 0 0  = 2 0 0 0
0 2 0 0        0 1 0 0    0 2 0 0
0 0 2 0        0 0 1 0    0 0 2 0
0 0 0 2        0 0 0 1    0 0 0 2

C00 = 2*1 + 0*0 + 0*0 + 0*0 = 2
C01 = 2*0 + 0*1 + 0*0 + 0*0 = 0
C02 = 2*0 + 0*0 + 0*1 + 0*0 = 0
C03 = 2*0 + 0*0 + 0*0 + 0*1 = 0

일반적인 곱셈할때 교환을 해도 문제가 있나요 없나요?
2 * 3
3 * 2

행렬은 다릅니다.
A차원 * B차원 = C차원
B차원 * A차원 = F차원

항등행렬 
A차원 * 항등행렬 = A차원
B차원 * 항등행렬 = B차원


기본값으로 씁니다. 

// 100.0f 100.0f 100.0f
벡터 * 차원

그 세계는 1280.0에 720의 크기를 가지고 있고
//       y가 뒤집어져 있는 세상을 만들고 싶어요.

// 모든 애들은 기본적으로 원점을 기준으로 한 세계에서 살고 있습니다.
// 원점밖에 없는 세상입니다.
// 대부분의 수학공식이 데카르트 좌표계를 기준으로 생각하기 때문에.
// 

열 가로 로 세라
행 세로 로 세라

첫째 행렬의 열 갯수와 둘째 행렬의 행 갯수가 동일해야한다. 
곱셈의 결과 

곱셈의 결과 새롭게 만들어진 행렬은 첫째 행렬의 행 갯수와 둘째 행렬의 열 갯수를 가진다.

왼쪽의 행과
오른쪽 의 열이 합쳐지는 결과가 나옵니다.

  4 x 4
  B           A              C
  3 0 0 0  *  1   = x
  0 1 0 0     1     y
  0 0 3 0     0     z
  0 0 0 1     0     w

이걸 크기 행렬이라고 합니다.

x = (-0.5 * 3) + (-0.5 * 0) + (0 * 0) + (0 * 0)
y = (-0.5 * 0) + (-0.5 * 1) + (0 * 0) + (0 * 0)
z = (-0.5 * 0) + (-0.5 * 0) + (0 * 3) + (0 * 0)
w = (-0.5 * 0) + (-0.5 * 0) + (0 * 0) + (0 * 3)

-0.5f,  0.5f
 0.5f,  0.5f
 0.5f, -0.5f
-0.5f, -0.5f

-1.5f,  0.5f
 1.5f,  0.5f
 1.5f, -0.5f
-1.5f, -0.5f


x = 3
y = 0
z = 0
w = 0

  4 x 4
  B          A            C
  1 1 0 0 *  3 0 0 0   = x y z w
             0 3 0 0       
             0 0 3 0       
             0 0 0 1       



// 이동행렬
  4 x 4
  B          A            C
  0.5 -0.5 0 1 *  1  0  0  0   = x y z w
                  0  1  0  0       
                  0  0  1  0       
                  10 10 10 1       


x = (-0.5 * 1) + (-0.5 * 0) + (0 * 0) + (1 * 10)
y = (-0.5 * 0) + (-0.5 * 1) + (0 * 0) + (1 * 10)
z = (-0.5 * 0) + (-0.5 * 0) + (0 * 1) + (1 * 10)
w = (-0.5 * 0) + (-0.5 * 0) + (0 * 0) + (1 * 1)


// 회전행렬
// 행렬이라는것은 이미 그자체로 사실 이동이면서
// 크기면서 
// 회전행렬인겁니다.

// 저 세라인이 바뀐게 

// 무조건 그 세계의 3개축의 단위백터로 구성되는것이 회전행렬이다.

1 0 0 0 
0 1 0 0 
0 0 1 0 
0 0 0 1 

1 0 0 0 
0-1 0 0 
0 0 1 0 
0 0 0 1 



x 축 회전
NextVector.y = _OriginVector.y * cosf(_Radian) - _OriginVector.z * sinf(_Radian);
NextVector.z = _OriginVector.y * sinf(_Radian) + _OriginVector.z * cosf(_Radian);
NextVector.x = _OriginVector.x;

  4 x 4
  B          A            
  1 1 0 0 *  1    0     0    0   
             0    cosf  -sinf0       
             0    sinf  cosf 0       
             0    0     0    1       


y 축 회전
NextVector.x = _OriginVector.x * cosf(_Radian) + _OriginVector.z * sinf(_Radian);
NextVector.z =  _OriginVector.x * -sinf(_Radian) + _OriginVector.z * cosf(_Radian);
NextVector.y = _OriginVector.y;

  4 x 4
  B          A            
  1 1 0 0 *  cosf 0     -sinf 0   
             0    1     0    0       
             sinf 0     cosf 0       
             0    0     0    1       

z 축 회전
NextVector.x = _OriginVector.x * cosf(_Radian) - _OriginVector.y * sinf(_Radian);
NextVector.y = _OriginVector.x * sinf(_Radian) + _OriginVector.y * cosf(_Radian);
NextVector.z = _OriginVector.z;



뷰의 

      로컬                            월드     뷰
       | 
       |                               |       |
버텍스  |크기 * 자전 * 이동 * 공전 * 부모 |* 뷰   |
       |                    항등   항등 |       |
       |                               |       |